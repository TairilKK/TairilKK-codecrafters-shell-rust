use std::env;
use std::fs;
use std::os::unix::fs::PermissionsExt;

use super::traits::Command;

const SEPARATOR: char = ':';

pub struct Type {
    commands: Vec<String>,
}

impl Type {
    pub fn new(commands: Vec<String>) -> Self {
        Self { commands }
    }

    fn is_command(&self, name: &String) -> bool {
        self.commands.contains(name)
    }

    fn is_executable(&self, name: &String) -> Option<String> {
        let dirs: Vec<String> = match env::var("PATH") {
            Ok(value) => value,
            Err(_) => "".to_string(),
        }
        .split(SEPARATOR)
        .map(|v| v.to_string())
        .collect();

        if dirs.is_empty() {
            return None;
        }

        for dir in dirs {
            let paths = fs::read_dir(dir);

            for path in paths {
                let entry = path.unwrap();

                if entry.file_name().to_str().unwrap() != name {
                    continue;
                }
                if entry.file_type().unwrap().is_file() {
                    let metadata = fs::metadata(entry.path()).expect("Unable to read metadata");

                    if metadata.permissions().mode() & 0o111 != 0 {
                        match entry.path().to_str() {
                            Some(value) => return Some(value.to_string()),
                            _ => continue,
                        }
                    }
                }
            }
        }
        None
    }
}

impl Command for Type {
    fn execute(&self, args: String) -> Result<(), ()> {
        match self.is_command(&args) {
            true => println!("{} is a shell builtin", args),
            false => match self.is_executable(&args) {
                Some(path) => println!("{} is", path),
                None => println!("{}: not found", args),
            },
        }

        Ok(())
    }
}
